% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/funDataMethods.R
\name{flipFuns}
\alias{flipFuns}
\title{Flip functional data objects}
\usage{
flipFuns(refObject, newObject)
}
\arguments{
\item{refObject}{An object of class \code{funData} or \code{multiFunData}
that serves as reference. It must have the same number of observations as
\code{newObject} or have only one observation. In this case, all
observations in \code{newObject} are flipped with respect to this single
observation.}

\item{newObject}{An object of class \code{funData} or \code{multiFunData}
  that is to be flipped with respect to \code{refObject}.}
}
\value{
An object of the same class as \code{newData} with flipped
  observations.
}
\description{
This function flips an object \code{newObject} of class \code{funData} or
\code{multiFunData} with respect to a reference object \code{refObject} of
the same class. This is particularly useful when dealing with functional
principal components, as they are only defined up to a sign change. For
details, see below.
}
\details{
Functional principal component analysis is an important tool in functional
data analysis. Just as eigenvectors, eigenfunctions (or functional principal
components) are only defined up to a sign change. This may lead to
difficulties in simulation studies or when bootstrapping pointwise confidence
bands, as in these cases one wants the estimates to have the same
"orientation" as the true function (in simulation settings) or the
non-bootstrapped estimate (when calculating bootstrap confidence bands). This
function allows to flip (i.e. multiply by \eqn{-1}{-1}) all observations in
\code{newObject} that have a different orientation than their counterparts in
\code{refData}.

Technically, the function looks for the coordinate \eqn{t^\ast}{t*} in the
domain (\code{xVal}) of \code{refObject}
\eqn{\phi_\mathrm{ref}(t)}{\phi_{ref}(t)} that has the highest absolute value
\deqn{t^\ast = \arg \max \limits_{t \in \mathcal{T}} | \phi_\mathrm{ref}(t) |
}{t* = arg max_{t in \calT} |\phi_{ref}(t)| } and then multiplies the
observation \eqn{\phi_\mathrm{new}(t)}{\phi_{new}(t)} by \eqn{-1}{-1} if
\deqn{\mathrm{sign}\left(\phi_\mathrm{ref}(t^\ast) \right) \neq
\mathrm{sign}\left(\phi_\mathrm{new}(t^\ast) \right).}{sign( \phi_{ref}(t*) )
!= sign( \phi_{new}(t*) ).}

For \code{multiFunData} objects, this is done element-wise.
}
\section{Warning}{
 This function only works if the functions in
  \code{refObject} and \code{newObject} are similar to each other. In
  particular, the reference object should not have an abrupt sign change near
  \eqn{t^\ast}{t*}, the coordinate with the maximum absolute value. As in
  this case, the new functions could be flipped in the wrong direction, if
  they are slightly shifted to the left or to the right. For
  \code{multiFunData} objects, check the results to make sure that the
  functions are smooth enough such that either all elements are flipped or
  none.

  The function is currently implemented only for functional data with one-
  and two-dimensional domains.
}
\examples{
xVal <- seq(0,2*pi,0.01)
refData <- funData(xVal, rbind(sin(xVal))) # one observation as reference
newData <- funData(xVal, outer(sample(c(-1,1), 11, replace = TRUE) * seq(0.75, 1.25, by = 0.05),
                               sin(xVal)))

oldpar <- par(no.readonly = TRUE)
par(mfrow = c(1,2))

plot(newData, col = "grey", main = "Original data")
plot(refData, col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refData, newData), col = "grey", main = "Flipped data")
plot(refData, col = "red", lwd = 2, add = TRUE)

par(oldpar)
}
\seealso{
\linkS4class{funData}, \linkS4class{multiFunData},
  \link{Arith.funData}
}

