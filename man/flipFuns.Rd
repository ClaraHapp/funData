% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/funDataMethods.R
\name{flipFuns}
\alias{flipFuns}
\title{Flip functional data objects}
\usage{
flipFuns(refObject, newObject, ...)
}
\arguments{
\item{refObject}{An object of class \code{funData} or \code{multiFunData}
that serves as reference. It must have the same number of observations as
\code{newObject} or have only one observation. In this case, all
observations in \code{newObject} are flipped with respect to this single
observation.}

\item{newObject}{An object of class \code{funData} or \code{multiFunData}
 that is to be flipped with respect to \code{refObject}.}

\item{...}{Further parameters passed to \code{\link{norm}}.}
}
\value{
An object of the same class as \code{newData} with flipped
  observations.
}
\description{
This function flips an object \code{newObject} of class \code{funData} or
\code{multiFunData} with respect to a reference object \code{refObject} of
the same class. This is particularly useful when dealing with functional
principal components, as they are only defined up to a sign change. For
details, see below.
}
\details{
Functional principal component analysis is an important tool in functional
data analysis. Just as eigenvectors, eigenfunctions (or functional principal
components) are only defined up to a sign change. This may lead to
difficulties in simulation studies or when bootstrapping pointwise confidence
bands, as in these cases one wants the estimates to have the same
"orientation" as the true function (in simulation settings) or the
non-bootstrapped estimate (when calculating bootstrap confidence bands). This
function allows to flip (i.e. multiply by \eqn{-1}{-1}) all observations in
\code{newObject} that have a different orientation than their counterparts in
\code{refData}.

Technically, the function compares the distance between \code{newObject} and
\code{refObject} \deqn{|||f_\text{new} - f_\text{ref}|||}{||| f_{new} -
f_{ref}|||} and the distance between  \code{newObject} and
\code{-1*refObject} \deqn{|||f_\text{new} + f_\text{ref}|||.}{||| f_{new} +
f_{ref}|||.} If \code{newObject} is closer to \code{-1*refObject}, it is
flipped, i.e. multiplied by -1.

The function is currently implemented only for functional data with one-
 and two-dimensional domains.
}
\examples{
# Univariate
xVal <- seq(0,2*pi,0.01)
refData <- funData(xVal, rbind(sin(xVal))) # one observation as reference
newData <- funData(xVal, outer(sample(c(-1,1), 11, replace = TRUE) * seq(0.75, 1.25, by = 0.05),
                               sin(xVal)))

oldpar <- par(no.readonly = TRUE)
par(mfrow = c(1,2))

plot(newData, col = "grey", main = "Original data")
plot(refData, col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refData, newData), col = "grey", main = "Flipped data")
plot(refData, col = "red", lwd = 2, add = TRUE)

# Multivariate
refData <- multiFunData(funData(xVal, rbind(sin(xVal))), # one observation as reference
                        funData(xVal, rbind(cos(xVal))))
sig <- sample(c(-1,1), 11, replace = TRUE)
newData <- multiFunData(funData(xVal, outer(sig * seq(0.75, 1.25, by = 0.05), sin(xVal))),
                        funData(xVal, outer(sig * seq(0.75, 1.25, by = 0.05), cos(xVal))))

par(mfrow = c(2,2))

plot(newData[[1]], col = topo.colors(11), main = "Original data")
plot(refData[[1]], col = "red", lwd = 2, add = TRUE)

plot(newData[[2]], col = topo.colors(11), main = "Original data")
plot(refData[[2]], col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refData, newData)[[1]], col = topo.colors(11), main = "Flipped data")
plot(refData[[1]], col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refData, newData)[[2]], col = topo.colors(11), main = "Flipped data")
plot(refData[[2]], col = "red", lwd = 2, add = TRUE)

par(oldpar)
}
\seealso{
\linkS4class{funData}, \linkS4class{multiFunData},
  \link{Arith.funData}
}

